
<html>
    <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <link rel="stylesheet" type="text/css" href="style.css" />
    <title>Chapter 1: Introduction</title>
    </head>
    <body>
    
    <h1>简介</h1>

    <p>
        理解事物如何工作的最好方法是尝试自己构建它。阅读别人的解释可能会满足您的好奇心，但是如果没有陷入所有小陷阱的经验，就很难理解<em>为什么</em>某些事物是以某种方式设计的。
    </p>

    <p>
        有人说，每个将来的程序员都应该编写一个编译器。尽管我认为这是个不错的建议（尽管我自己并没有遵循），但是在解析诸如C之类的语言时需要付出大量的努力，以至于任何潜在的见解都有可能迷失在细节中。也许为一些简单的语言创建一个解释器将是一个很好的第一步。
    </p>
    
    <p>
        早在几年前，我就开始与LISP一起玩耍，但是比我本来应该晚得多。这使我进入了经典的讲座系列<a href="http://groups.csail.mit.edu/mac/classes/6.001/abelson-sussman-lectures/">“计算机程序的结构和解释”</a>。如果您在接下来的24小时有空，还没有看过这些视频，请立即观看。
    </p>
    
    <p>
        该课程涵盖许多主题，但是下半部分将详细介绍如何评估LISP，首先是通过eval在LISP本身中实现一个简单的版本 。我认为这可以很好地转换为C，因此决定尝试创建自己的LISP实现。
    </p>
    
    <p>
        真的很简单。
    </p>
    
    <p>
        本文试图共享构建实施过程的过程，各章的执行顺序大致相同。为什么不遵循并以您选择的语言创建自己的版本？<a href="#f1"><sup>*</sup></a>
    </p>

    <p>
        作为一名专业程序员（ha，ha），我将大部分时间都花在编写C和C ++上。其余大多数是Java。有很多语言在那里，每个都有自己的优点值得商榷，但我想证明是多么简单的一个LISP机可-甚至建在低层次的语言为C.见约翰麦卡锡的<a href="http://www-formal.stanford.edu/jmc/history/lisp/lisp.html">LISP的历史</a>了开拓者的故事。
    </p>
    
    <p>
        所以这是我的LISP的玩具实现。我已经从各种方言中借用了功能，但是它比Common LISP更接近Scheme。差异是微不足道的，以至于转换不需要对解释程序进行实质性的更改。如果您不熟悉LISP，请不要担心。我将在前进的过程中定义所有内容。
    </p>
    
    <p>
        它既不是最小的实现，也不是最高效的，也不是最完整的实现。但是它可以说是懒惰的。我的目标是编写功能强大，易于阅读的代码，该代码完全满足其需要，并且不再需要执行任何其他操作，并且我希望它可以传达构建诸如LISP之类的功能强大的环境所需的工作量。
    </p>
    
    <hr />
    
    <small>
    
    <p id="f1">
    <sup>*</sup> 如果使用的是支持像的奇特语言<code>eval</code>，将本地数据类型暴露给LISP环境将很酷。
    </p>
    
    </small>
    
    </body>
    </html>
    
    