
<html>
    <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <link rel="stylesheet" type="text/css" href="style.css" />
    <title>第二章：数据</title>
    </head>
    <body>
    
    <h1>数据</h1>
    
    <p>
        我们将首先定义四种对象：
    <dl>
     <dt>整数</dt>
     <dd>数字。 例如：3, -9, 0。</dd>
     <dt>符号</dt>
     <dd>由字符串组成的名称。例如：<code>FOO</code>, <code>BAR</code>, <code>ADD-TWO</code>.
        我们将在此项目中将字符规范化为大写，但这不是绝对必要的。</dd>
     <dt><code>NIL</code></dt>
     <dd>代表“无”。 有点像C语言和其他语言中的<code>NULL</code>。</dd>
     <dt>对</dt>
     <dd>对由两个元素组成，出于历史原因，它们被称为 <i>car</i> 和 <i>cdr</i>. 两者都可以容纳整数, 符号, <code>NIL</code>, 或者其他“对”的 <em>引用</em>。
        每个元素的类型可能不同。</dd>
    </dl>
    Integers, symbols and <code>NIL</code> are called <i>simple data</i>.
    The term <i>atom</i> can refer to either a simple datum or a pair
    (purists may disagree on this point).
    </p>
    
    <p>
        请注意，整数和符号是<em>不可变的</em>，因此我们可以将具有相同值的两个整数视为同一对象。这对符号特别有用，因为它允许我们通过比较指针来测试是否相等。
    </p>
    
    <h4>实现</h4>
    
    <p>
        让我们声明一些C类型来保存我们的数据。有许多聪明的方法可以有效地存储LISP对象，但是对于此实现，我们将坚持一个非常简单的方案 <small>[请原谅，哈哈]</small>.
    </p>
    
    <pre class="c">
    struct Atom {
        enum {
            AtomType_Nil,
            AtomType_Pair,
            AtomType_Symbol,
            AtomType_Integer
        } type;
    
        union {
            struct Pair *pair;
            const char *symbol;
            long integer;
        } value;
    };
    
    struct Pair {
        struct Atom atom[2];
    };
    
    typedef struct Atom Atom;
    </pre>
    
    <p>
    一些宏将很方便：
    <pre class="c">
    #define car(p) ((p).value.pair-&gt;atom[0])
    #define cdr(p) ((p).value.pair-&gt;atom[1])
    #define nilp(atom) ((atom).type == AtomType_Nil)
    
    static const Atom nil = { AtomType_Nil };
    </pre>
    The "p" in <code>nilp</code> stands for "predicate". Identifiers in C
    may not contain question marks. There is no need to restrict our LISP
    implementation in that way, of course.
    </p>
    
    <p>
    Integers and (pointers to) strings can be copied around, but we need to
    allocate pairs on the heap.
    <pre class="c">
    Atom cons(Atom car_val, Atom cdr_val)
    {
        Atom p;
    
        p.type = AtomType_Pair;
        p.value.pair = malloc(sizeof(struct Pair));
    
        car(p) = car_val;
        cdr(p) = cdr_val;
    
        return p;
    }
    </pre>
    <code>cons</code> is a function to allocate a pair on the heap and
    assign its two elements.
    </p>
    
    <p>
    At this point you will have noticed that using <code>cons</code> will
    leak memory the moment its return value is discarded. We will deal with
    that later. Of course, if you are using a garbage-collected language
    then the problem is already taken care of.
    </p>
    
    <h4>Testing</h4>
    
    <p>
    Now we can start creating LISP objects. An integer:
    <pre class="c">
    Atom make_int(long x)
    {
        Atom a;
        a.type = AtomType_Integer;
        a.value.integer = x;
        return a;
    }
    </pre>
    And a symbol:
    <pre class="c">
    Atom make_sym(const char *s)
    {
        Atom a;
        a.type = AtomType_Symbol;
        a.value.symbol = strdup(s);
        return a;
    }
    </pre>
    </p>
    
    <h2>Textual representation</h2>
    
    <p>
    We will write a pair like this:
    <pre class="lisp">(a . b)</pre>
    where <code>a</code> is the <i>car</i> and <code>b</code> is the
    <i>cdr</i>.
    </p>
    
    <p>
    By using the <i>cdr</i> of a pair to reference another pair, we can
    create a chain:
    <pre class="lisp">
    (a . (b . (c . (d . NIL))))
    </pre>
    Notice that the <i>cdr</i> of the last pair is <code>NIL</code>. This
    signifies the end of the chain, and we call this structure a
    <em>list</em>. To avoid having to write a large number of brackets, we
    will write the previous list like this:
    <pre class="lisp">(a b c d)</pre>
    Finally, if the <i>cdr</i> of the last pair in a list is not
    <code>NIL</code>, we will write this:
    <pre class="lisp">(p q . r)</pre>
    which is equivalent to
    <pre class="lisp">(p . (q . r))</pre>
    This is called an <i>improper list</i>.
    </p>
    
    <h4>Implementation</h4>
    
    <p>
    Printing an atom or list is simple.
    <pre class="c">
    void print_expr(Atom atom)
    {
        switch (atom.type) {
        case AtomType_Nil:
            printf("NIL");
            break;
        case AtomType_Pair:
            putchar('(');
            print_expr(car(atom));
            atom = cdr(atom);
            while (!nilp(atom)) {
                if (atom.type == AtomType_Pair) {
                    putchar(' ');
                    print_expr(car(atom));
                    atom = cdr(atom);
                } else {
                    printf(" . ");
                    print_expr(atom);
                    break;
                }
            }
            putchar(')');
            break;
        case AtomType_Symbol:
            printf("%s", atom.value.symbol);
            break;
        case AtomType_Integer:
            printf("%ld", atom.value.integer);
            break;
        }
    }
    </pre>
    By using recursion we can print aribtrarily complex data structures.
    (Actually that's not true: for a very deeply nested structure we will
    run out of stack space, and a self-referencing tree will never finish
    printing).
    </p>
    
    <h4>Testing</h4>
    
    <p>
    See what <code>print_expr</code> does with various atoms:
    <table border="1">
     <tr><th>Atom</th><th>Output</th></tr>
     <tr><td><code>make_int(42)</code><td><code>42</code></td>
     <tr><td><code>make_sym("FOO")</code><td><code>FOO</code></td>
     <tr><td><code>cons(make_sym("X"), make_sym("Y"))</code><td><code>(X . Y)</code></td>
     <tr><td><code>cons(make_int(1),<br />
       &nbsp;&nbsp;cons(make_int(2),<br />
       &nbsp;&nbsp;cons(make_int(3),<br />
       &nbsp;&nbsp;nil)))</code><td><code>(1 2 3)</code></td>
    </table>
    </p>
    
    <p>
    All this is pretty trivial. We'll get on to some more interesting stuff
    in the next chapter.
    </p>
    
    <h3>One last thing</h3>
    
    <p>
    Remember we said that we would treat identical symbols as being the
    same object? We can enforce that by keeping track of all the symbols
    created, and returning the same atom if the same sequence of characters
    is requested subsequently.
    </p>
    
    <p>
    Languages with a set or hashtable container make this easy, but we can
    use the LISP data structures already implemented to store the symbols
    in a list:
    <pre class="c">
    static Atom sym_table = { AtomType_Nil };
    
    Atom make_sym(const char *s)
    {
        Atom a, p;
    
        p = sym_table;
        while (!nilp(p)) {
            a = car(p);
            if (strcmp(a.value.symbol, s) == 0)
                return a;
            p = cdr(p);
        }
    
        a.type = AtomType_Symbol;
        a.value.symbol = strdup(s);
        sym_table = cons(a, sym_table);
    
        return a;
    }
    </pre>
    Neat, huh? It's not particularly efficient, but it will do fine for now.
    </p>

    <pre class="c">
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <ctype.h>
#include <readline/readline.h>

typedef enum {
    Error_OK = 0,
    Error_Syntax
} Error;

struct Atom
{
    enum {
        AtomType_Nil,
        AtomType_Pair,
        AtomType_Symbol,
        AtomType_Integer
    } type;

    union {
        struct Pair *pair;
        const char *symbol;
        long integer;
    } value;
};

struct Pair {
    struct Atom atom[2];
};

typedef struct Atom Atom;

#define car(p) ((p).value.pair->atom[0])
#define cdr(p) ((p).value.pair->atom[1])
#define nilp(atom) ((atom).type == AtomType_Nil)

static const Atom nil = { AtomType_Nil };

Atom cons(Atom car_val, Atom cdr_val)
{
    Atom p;

    p.type = AtomType_Pair;
    p.value.pair = malloc(sizeof(struct Pair));

    car(p) = car_val;
    cdr(p) = cdr_val;

    return p;
}

Atom make_int(long x)
{
    Atom a;
    a.type = AtomType_Integer;
    a.value.integer = x;
    return a;
}

Atom make_sym(const char *s)
{
    Atom a;
    a.type = AtomType_Symbol;
    a.value.symbol = strdup(s);
    return a;
}

int lex(const char *str, const char **start, const char **end)
{
    const char *ws = " \t\n";
    const char *delim = "() \t\n";
    const char *prefix = "()";

    str += strspn(str, ws);

    if (str[0] == '\0') {
        *start = *end = NULL;
        return Error_Syntax;
    }

    *start = str;

    // strchr函数功能为在一个串中查找给定字符的第一个匹配之处
    if (strchr(prefix, str[0]) != NULL)
        *end = str + 1;
    else
    // 该函数返回 str1 开头连续都不含字符串 str2 中字符的字符数。
        *end = str + strcspn(str, delim);

    return Error_OK;
}

int read_expr(const char *input, const char **end, Atom *result);

int parse_simple(const char *start, const char *end, Atom *result)
{
    char *buf, *p;

    long val = strtol(start, &p, 10);
    if (p == end) {
        result->type = AtomType_Integer;
        result->value.integer = val;
        return Error_OK;
    }

    buf = malloc(end - start + 1);
    p = buf;
    while (start != end)
        *p++ = toupper(*start), ++start;
    *p = '\0';

    if (strcmp(buf, "NIL") == 0) {
        *result = nil;
    } else {
        *result = make_sym(buf);
    }

    free(buf);
    
    return Error_OK;
}

int read_list(const char *start, const char **end, Atom *result)
{
    Atom p;

    *end = start;
    p = *result = nil;

    for (;;) {
        const char *token;
        Atom item;
        Error err;

        err = lex(*end, &token, end);
        if (err) {
            return err;
        }

        if (token[0] == ')') {
            return Error_OK;
        }

        if (token[0] == '.' && *end - token == 1) {
            if (nilp(p)) {
                return Error_Syntax;
            }

            err = read_expr(*end, end, &item);
            if (err) {
                return err;
            }

            cdr(p) = item;

            err = lex(*end, &token, end);
            if (!err && token[0] != ')') {
                err = Error_Syntax;
            }

            return err;
        }

        err = read_expr(token, end, &item);
        if (err) {
            return err;
        }

        if (nilp(p)) {
            *result = cons(item, nil);
            p = *result;
        } else {
            cdr(p) = cons(item, nil);
            p = cdr(p);
        }
    }
}

int read_expr(const char *input, const char **end, Atom *result)
{
    const char *token;
    Error err;

    err = lex(input, &token, end);
    if (err) return err;

    if (token[0] == '(') {
        return read_list(*end, end, result);
    } else if (token[0] == ')') {
        return Error_Syntax;
    } else {
        return parse_simple(token, *end, result);
    }
}

void print_expr(Atom atom)
{
    switch (atom.type)
    {
    case AtomType_Nil:
        printf("NIL");
        break;

    case AtomType_Pair:
        putchar('(');
        print_expr(car(atom));
        atom = cdr(atom);
        while (!nilp(atom)) {
            if (atom.type == AtomType_Pair) {
                putchar(' ');
                print_expr(car(atom));
                atom = cdr(atom);
            } else {
                printf(" . ");
                print_expr(atom);
                break;
            }
        }
        putchar(')');
        break;

    case AtomType_Symbol:
        printf("%s", atom.value.symbol);
        break;

    case AtomType_Integer:
        printf("%ld", atom.value.integer);
        break;
    
    default:
        break;
    }
}



int main(int argc, char const *argv[])
{
    char *input;

    while ((input = readline("> ")) != NULL) {
        const char *p = input;
        Error err;
        Atom expr;

        err = read_expr(p, &p, &expr);

        switch (err)
        {
        case Error_OK:
            print_expr(expr);
            putchar('\n');
            break;
        case Error_Syntax:
            puts("Syntax error");
            break;
        }

        free(input);
    }

    return 0;
}    
    </pre>

    编译命令(MacOS)

    <pre>
        gcc -lreadline lisp.c -o lisp
    </pre>
    
    </body>
    </html>
    
    